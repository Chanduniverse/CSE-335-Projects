/**
 * \file CityReport.h
 *
 * \author Charles B. Owen
 *
 * The city report is generated by the members of the city.
 * It is a collection of objects of type CMemberReport.
 */

#pragma once

#include <memory>
#include <vector>
#include <list>

class CCity;
class CMemberReport;

/**
 * The city report is generated by the members of the city.
 * It is a collection of objects of type CMemberReport.
*/
class CCityReport
{
public:
    CCityReport(CCity* city);

    void Add(std::shared_ptr<CMemberReport> report);


private:
    /// The city this report is for
    CCity* mCity;

protected:
    /**
     * A bin holds some number of member reports
     */
    class Bin {
    public:
        /// A vector of reports stored in this Bin
        std::vector < std::shared_ptr<CMemberReport>> mReports;
    };

    /// The list of Bin objects holding report data.
    std::list<Bin> mBins;

public:
    /** Iterator that iterates over the items in the collection */
    class Iter
    {
    public:
        /** Constructor
        * \param binIter the bin iterator
        * \param pos track postion in a bin
        * \param collection The collection we are iterating over */
        Iter(CCityReport* collection, std::list<Bin>::iterator binIter, int pos) : mCollection(collection), mBinIterator(binIter), mPos(pos) {}

        /** Test for end of the iterator
        * \param other The other iterator
        * \returns True if we this position equals not equal to the other position */
        bool operator!=(const Iter& other) const
        {
            return mPos != other.mPos || mBinIterator != other.mBinIterator;
        }

        /** Get value at current position
        * \returns Value at mPos in the collection */
        std::shared_ptr<CMemberReport> operator *() const { return mBinIterator->mReports[mPos]; }

        /** Increment the iterator
        * \returns Reference to this iterator */
        const Iter& operator++()
        {
            mPos++;
            if (mPos == mBinIterator->mReports.size())
            {
                mPos = 0;
                mBinIterator++;
            }
            return *this;
        }

    private:
        CCityReport* mCollection;	///< Collection we are iterating over
        std::list<Bin>::iterator mBinIterator; ///< iterator of bins in collection
        int mPos;	///< Position in the collection
    };

    /** Get an iterator for the beginning of the collection
    * \returns Iter object at last location in the array */
    Iter begin() { return Iter(this, mBins.begin(), 0); }

    /** Get an iterator for the end of the collection
    * \returns Iter object at position past the front */
    Iter end() { return Iter(this, mBins.end(), 0); }
};

